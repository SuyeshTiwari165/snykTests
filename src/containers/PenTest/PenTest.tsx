import React, { useState, useEffect } from "react";
import CssBaseline from "@material-ui/core/CssBaseline";
import Typography from "@material-ui/core/Typography";
import { Grid } from "@material-ui/core";
import styles from "./PenTest.module.css";
import { useQuery, useLazyQuery, useMutation } from "@apollo/client";
import { SUCCESS, UPDATE, DELETE, FAILED } from "../../common/MessageConstants";
import Alert from "../../components/UI/Alert/Alert";
import IconButton from "@material-ui/core/IconButton";
import CloseIcon from "@material-ui/icons/Close";
import Input from "../../components/UI/Form/Input/Input";
import { Button } from "../../components/UI/Form/Button/Button";
import AutoCompleteDropDown from "../../components/UI/Form/Autocomplete/Autocomplete";
import * as routeConstant from "../../common/RouteConstants";
import { useHistory } from "react-router";
import {
  PENTEST_SCAN_POLICY,
  CREATE_PENTEST_TARGET,
} from "../../graphql/queries/PenTest";
import Cookies from "js-cookie";
import { createMuiTheme, MuiThemeProvider } from "@material-ui/core/styles";
import Tooltip from "@material-ui/core/Tooltip";
import { DOMAIN_VERIFY, IP_VERIFY , URL_VERIFY } from "../../graphql/mutations/DomainVerify";
import * as msgConstant from "../../common/MessageConstants";
import SimpleBackdrop from "../../components/UI/Layout/Backdrop/Backdrop";

const theme = createMuiTheme({
  overrides: {
    MuiTooltip: {
      tooltip: {
        backgroundColor: "rgb(240, 102, 1, 0.8)",
        borderRadius: "12px",
        position: "relative",
        "&:before": {
          content: "' '",
          width: "0px",
          height: "0px",
          zIndex: 9999,
          position: "absolute",
        },
      },
      tooltipPlacementRight: {
        "&:before": {
          borderTop: "6px solid transparent",
          borderBottom: "6px solid transparent",
          borderRight: "6px solid rgba(240, 102, 1, 0.8)",
          left: "-6px",
          top: "45%",
        },
      },
      tooltipPlacementLeft: {
        "&:before": {
          borderTop: "6px solid transparent",
          borderBottom: "6px solid transparent",
          borderLeft: "6px solid rgba(240, 102, 1, 0.8)",
          right: "-6px",
          top: "45%",
        },
      },
      tooltipPlacementBottom: {
        "&:before": {
          borderLeft: "6px solid transparent",
          borderRight: "6px solid transparent",
          borderBottom: "6px solid rgba(240, 102, 1, 0.8)",
          left: "45%",
          top: "-6px",
        },
      },
      tooltipPlacementTop: {
        "&:before": {
          borderLeft: "6px solid transparent",
          borderRight: "6px solid transparent",
          borderTop: "6px solid rgba(240, 102, 1, 0.8)",
          left: "45%",
          bottom: "-6px",
        },
      },
    },
  },
});

export const PenTest: React.FC = (props: any) => {
  let { name, partnerId, clientId } = props?.location.state?.clientInfo;
  const history = useHistory();
  const partner = Cookies.get("ob_partnerData") || "";
  let partnerdata = JSON.parse(partner);
  const [url, setUrl] = useState<any>("");
  const [targetName, setTargetName] = useState<String>("");
  const [params, setParams] = useState<any>();
  const [policyValue, setPolicyValue] = useState<any>("");
  const [policyList, setPolicyList] = useState<any>([]);
  const [reset, setReset] = useState<boolean>(false);
  const [targetOpen, setTargetOpen] = useState(false);
  const [targetCreated, setTargetCreated] = useState(false);
  const [urlOpen, setUrlOpen] = useState(false);
  const startDate = new Date();
  const [submitDisabled, setSubmitDisabled] = useState(true);
  const [formState, setFormState] = useState({
    isSuccess: false,
    isUpdate: false,
    isFailed: false,
    isDelete: false,
    errMessage: "",
  });
  const [isError, setIsError] = useState<any>({
    url: "",
    policyValue: "",
    targetName: "",
  });
  const clientInfo = props.location.state ? props.location.state.clientInfo : undefined;
  const [backdrop, setBackdrop] = useState(false);

  useEffect(() => {
    setParams(props?.location.state);
    getScanPolicies();
    setSubmitDisabled(checkValidation);
    checkValidation();
  }, []);

  useEffect(() => {
    if(targetCreated === true) {
    setFormState((formState) => ({
      ...formState,
      isSuccess: true,
      isUpdate: false,
      isDelete: false,
      isFailed: false,
      errMessage: 'Scan Created Successfully.',
    }));
    
  }
  }, [targetCreated]);

  
  const [createPenTestTarget] = useMutation(CREATE_PENTEST_TARGET);
  const [IPVerify] = useMutation(IP_VERIFY);
  const [domainVerify] = useMutation(DOMAIN_VERIFY);
  const [urlVerify] = useMutation(URL_VERIFY);
  
  const [getScanPolicies, { data: spData, loading: spLoading }] = useLazyQuery(
    PENTEST_SCAN_POLICY,
    {
      fetchPolicy: "cache-and-network",
      onCompleted: (data: any) => {
        let arr: any = [];
        data.getPentestScanPolicy.edges.map((element: any, index: any) => {
          let obj: any = {};
          obj["policyType"] = element.node.policyType;
          arr.push(obj);
        });
        setPolicyList(arr);
      },
      onError: (error) => {
        history.push(routeConstant.CLIENT);
      },
    }
  );

  const getAllPolicyValues = {
    options: policyList,
    getOptionLabel: (option: { policyType: String }) => option.policyType,
  };

  const checkValidation = () => {
    if (
      isError.targetName !== "" ||
      isError.url !== "" ||
      isError.policyValue !== "" ||
      !targetName ||
      !url ||
      !policyValue
    ) {
      return true;
    }
    return false;
  };

  const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setTargetName(event.target.value);
    if (!/[^a-zA-Z0-9\- \/]/.test(event.target.value)) {
      let value = event.target.value;
      let isErrName = value.length <= 0 ? "Required" : "";
      setIsError((isError: any) => ({
        ...isError,
        name: isErrName,
      }));
      setSubmitDisabled(checkValidation);
    }
    if (/[^a-zA-Z0-9\- \/]/.test(event.target.value)) {
      setIsError((isError: any) => ({
        ...isError,
        name: "Invalid Target Name",
      }));
    }
  };

  const validURL = (str: any) => {
    var pattern = new RegExp(
      "^(https?:\\/\\/)?" + // protocol
        "((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|" + // domain name
        "((\\d{1,3}\\.){3}\\d{1,3}))" + // OR ip (v4) address
        "(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*" + // port and path
        "(\\?[;&a-z\\d%_.~+=-]*)?" + // query string
        "(\\#[-a-z\\d_]*)?$",
      "i"
    ); // fragment locator
    return !!pattern.test(str);
  };

  const handleChangeUrl = (event: any) => {
    setUrl(event?.target.value);
    if (event.target.value) {
      // if(!validateText(url)) {
      //    setIsError((isError: any) => ({
      //   ...isError,
      //   url: "Invalid Url",
      // }));
      // }
      console.log("validUrl", validURL(event.target.value));
    }
    setSubmitDisabled(checkValidation);
  };

  const handlePolicyValueChange = (event: any, newValue: any) => {
    setPolicyValue(newValue);
    setSubmitDisabled(checkValidation);
  };

  const submitAction =  () => {
    
    let input = {
      "host" : url
    };
    //   urlVerify({
    //   variables: {
    //     input
    //   },
    // })
    // .then((userRes) => {
      // if(userRes.data.pturlVerify.status === 'Valid URL') {
        createPenTestTarget({
      variables: {
        TargetInput: {
          targetName: targetName,
          partner: parseInt(
            partnerdata.data.getPartnerUserDetails.edges[0].node.partnerId.id
          ),
          startDate: startDate,
          client: parseInt(params.clientInfo.clientId),
          host: url,
          scanType: "Pentest",
          scanPolicyType: policyValue.policyType,
        },
      },
    })
      .then((res: any) => {
        setBackdrop(false)
        // console.log("res", res.data.createPenTest.targetField.targetName);
        // if(res.data..targetField === null) {
          if(res.data.createPenTest.status === "Duplicate") {
            setBackdrop(false);
          setFormState((formState) => ({
            ...formState,
            isSuccess: false,
            isUpdate: false,
            isDelete: false,
            isFailed: true,
            errMessage: " Scan name exists. Add another name ",
          }));
        } 
        else if(res.data.createPenTest.status === "Success") {
          setBackdrop(false)
        setFormState((formState) => ({
          ...formState,
          isSuccess: true,
          isUpdate: false,
          isDelete: false,
          isFailed: false,
          errMessage: `${res.data.createPenTest.targetField.targetName} Scan Created Successfully.`,
        }));
        let formState2 = {
          isSuccess: true,
          isUpdate: false,
          isDelete: false,
          isFailed: false,
          errMessage: msgConstant.SCAN_SUCCESS_MSG,
        }     
        setUrl("");
        setPolicyValue("");
        setTargetName("");
        // handleBack(); 
        if (Cookies.getJSON("ob_session")) {
          let data = {};
          data = { refetchData: true, clientInfo: clientInfo , formState : formState2};
          history.push(routeConstant.RA_REPORT_LISTING, data);
          localStorage.removeItem("name");
          localStorage.removeItem("targetId");
          localStorage.removeItem("ipRange");
          localStorage.removeItem("ipAddress");
          localStorage.removeItem("re-runTargetName");
          localStorage.removeItem("userName");
          localStorage.removeItem("password");
          localStorage.removeItem("vpnUserName");
          localStorage.removeItem("vpnPassword");
          localStorage.removeItem("vpnFilePath");
          localStorage.removeItem("WinTargetName");
          localStorage.removeItem("LinuxTargetName");
        } else {
          // logout();
        }
      }
      else {
        setBackdrop(false)
        setFormState((formState) => ({
          ...formState,
          isSuccess: false,
          isUpdate: false,
          isDelete: false,
          isFailed: true,
          errMessage: " Failed to create Scan Please Try Again",
        }));
      }
      })
      .catch((error) => {
        setBackdrop(false)
        console.log("error", error);
        setFormState((formState) => ({
          ...formState,
          isSuccess: false,
          isUpdate: false,
          isDelete: false,
          isFailed: true,
          errMessage: " Please fill in all the required fields ",
        }));
      });
    // }
    // if(userRes.data.pturlVerify.status === 'Invalid URL') {
    //   setFormState((formState) => ({
    //     ...formState,
    //     isSuccess: false,
    //     isUpdate: false,
    //     isDelete: false,
    //     isFailed: true,
    //     errMessage: " Please Enter Valid URL",
    //   }));
    // }
    // })  
    // .catch((error) => {
    //   console.log("ERROR",error)
    // });
  } 
  const handleSubmitDialogBox = () => {
    setBackdrop(true);

    // let input = {
    //   host: url,
    // };
    // if (url) {
    //   domainVerify({
    //     // IPVerify({
    //     variables: {
    //       input,
    //     },
    //   }).then((userRes) => {
    //     console.log("userRes", userRes);
    //   });
    // }
  //   if(!validateText(url)) {
  //     setIsError((isError: any) => ({
  //    ...isError,
  //    url: "Invalid Url",
  //  }));
  // }

    if (targetName && url && policyValue) {
    
    //   if(parseInt(url)){
    //     let input = {
    //       "host" : url,
    //       "scanType": "Pentest"
    //     };
    //     IPVerify({
    //     variables: {
    //       input
    //     },
    //   })
    //   .then((userRes) => {
    //     if(userRes.data.IPVerify.status === 'Valid IP address') {
    //       submitAction()
    //     }
    //      else if (userRes.data.IPVerify.status === 'Provide single ip address'){
    //       setBackdrop(false)
    //       setFormState((formState) => ({
    //         ...formState,
    //         isSuccess: false,
    //         isUpdate: false,
    //         isDelete: false,
    //         isFailed: true,
    //         errMessage: " Please Enter Single IP Address",
    //       }));
    //     }  else {
    //       // setBackdrop(false)
    //       setBackdrop(false)
    //       setFormState((formState) => ({
    //         ...formState,
    //         isSuccess: false,
    //         isUpdate: false,
    //         isDelete: false,
    //         isFailed: true,
    //         errMessage: " Please Enter Valid IP",
    //       }));
    //     }
    //   })
    //   .catch((err) => {
    //     setBackdrop(false)

    //     // setBackdrop(false);
    //     let error = err.message;
    //     setFormState((formState) => ({
    //       ...formState,
    //       isSuccess: false,
    //       isUpdate: false,
    //       isDelete: false,
    //       isFailed: true,
    //       errMessage: error,
    //     }));
    //   });
    // }
    // else {
      let input = {
        "host" : url
      };
      urlVerify({
      variables: {
        input
      },
    })
    .then((userRes) => {
      if(userRes.data.pturlVerify.status === 'Domain name is registered') {
        submitAction()
      } else if(userRes.data.pturlVerify.status === "Invalid URL")  {
        setBackdrop(false)
        setFormState((formState) => ({
          ...formState,
          isSuccess: false,
          isUpdate: false,
          isDelete: false,
          isFailed: true,
          errMessage: " Please enter a valid URL. Protocol is required (http://, or https://)",
        }));
      }
      else {
        setBackdrop(false)
        setFormState((formState) => ({
          ...formState,
          isSuccess: false,
          isUpdate: false,
          isDelete: false,
          isFailed: true,
          errMessage: " Please provide a valid URL or IP address and ensure that it is publicly hosted and accessible",
        }));
      }
    })
    .catch((err) => {
      setBackdrop(false);
      let error = err.message;
      setFormState((formState) => ({
        ...formState,
        isSuccess: false,
        isUpdate: false,
        isDelete: false,
        isFailed: true,
        errMessage: error,
      }));
    });
  // }
        // submit();
    } else {
      setFormState((formState) => ({
        ...formState,
        isSuccess: false,
        isUpdate: false,
        isDelete: false,
        isFailed: true,
        errMessage: " Please fill in all the required fields ",
      }));
    }
  };

  const handleAlertClose = () => {
    setFormState((formState) => ({
      ...formState,
      isSuccess: false,
      isUpdate: false,
      isDelete: false,
      isFailed: false,
      errMessage: "",
    }));
  };

  const handleBack = () => {
    // history.push(routeConstant.RA_REPORT_LISTING);
    if (Cookies.getJSON("ob_session")) {
      let data = {};
      data = { refetchData: true, clientInfo: clientInfo };
      if (params.previousPage === "client") {
        history.push(routeConstant.CLIENT, data);
        localStorage.removeItem("name");
        localStorage.removeItem("targetId");
        localStorage.removeItem("ipRange");
        localStorage.removeItem("ipAddress");
        localStorage.removeItem("re-runTargetName");
        localStorage.removeItem("userName");
        localStorage.removeItem("password");
        localStorage.removeItem("vpnUserName");
        localStorage.removeItem("vpnPassword");
        localStorage.removeItem("vpnFilePath");
        localStorage.removeItem("WinTargetName");
        localStorage.removeItem("LinuxTargetName");
      } else {
        history.push(routeConstant.RA_REPORT_LISTING, data);
        localStorage.removeItem("name");
        localStorage.removeItem("targetId");
        localStorage.removeItem("ipRange");
        localStorage.removeItem("ipAddress");
        localStorage.removeItem("re-runTargetName");
        localStorage.removeItem("userName");
        localStorage.removeItem("password");
        localStorage.removeItem("vpnUserName");
        localStorage.removeItem("vpnPassword");
        localStorage.removeItem("vpnFilePath");
        localStorage.removeItem("WinTargetName");
        localStorage.removeItem("LinuxTargetName");
      }
     
    } else {
      // logout();
    }
  };

  const handleTargetToolTipClose = () => {
    setTargetOpen(false);
  };

  const handleTargetToolTipOpen = () => {
    setTargetOpen(true);
  };

  const handleUrlToolTipClose = () => {
    setUrlOpen(false);
  };

  const handleUrlToolTipOpen = () => {
    setUrlOpen(true);
  };

  function validateText(str : any) { 
    var tarea = str; 
    let flag = false
    // if (tarea.indexOf("http://") == 0 || tarea.indexOf("https://") == 0) { 
       // do something here 
       if(tarea.contains("http://") || tarea.contains("https://") ) {
       flag = false
       
      }
      return true
    // else {
    //   return false
    // }
    }



  
  return (
    <React.Fragment>
      <CssBaseline />
      <Typography component="h5" variant="h1">
        Pen Test for {name}
        {/* {props?.location.state !== undefined &&
        props?.location.state.clientInfo !== undefined
          ? props?.location.state.clientInfo.name
          : null} */}
      </Typography>
      <Grid container spacing={3} className={styles.AlertWrap}>
        {" "}
        <Grid item xs={12}>
          {formState.isSuccess ? (
            <Alert
              severity="success"
              action={
                <IconButton
                  aria-label="close"
                  color="inherit"
                  size="small"
                  onClick={handleAlertClose}
                >
                  <CloseIcon fontSize="inherit" />
                </IconButton>
              }
            >
              <strong>{formState.errMessage}</strong>
              {/* {SUCCESS} */}
            </Alert>
          ) : null}
          {formState.isUpdate ? (
            <Alert
              severity="success"
              action={
                <IconButton
                  aria-label="close"
                  color="inherit"
                  size="small"
                  onClick={handleAlertClose}
                >
                  <CloseIcon fontSize="inherit" />
                </IconButton>
              }
            >
              <strong>{formState.errMessage}</strong>
              {/* {SUCCESS} */}
            </Alert>
          ) : null}
          {formState.isFailed ? (
            <Alert
              severity="error"
              action={
                <IconButton
                  aria-label="close"
                  color="inherit"
                  size="small"
                  onClick={handleAlertClose}
                >
                  <CloseIcon fontSize="inherit" />
                </IconButton>
              }
            >
              {FAILED}
              {formState.errMessage}
            </Alert>
          ) : null}
        </Grid>
        {backdrop ? <SimpleBackdrop /> : null}

        <Grid
          item
          xs={12}
          md={6}
          className={
            props.location.state != undefined && props.location.state.editData
              ? styles.disfield
              : styles.inputs
          }
        >
          <span className={styles.IPTooltip}>
            {/* <MuiThemeProvider theme={theme}> */}
              <Tooltip
                open={targetOpen}
                onClose={handleTargetToolTipClose}
                onOpen={handleTargetToolTipOpen}
                placement="bottom-end"
                title={
                  <React.Fragment>
                    <p>
                      <b> Scan Name can't contain any special characters. </b>{" "}
                    </p>{" "}
                  </React.Fragment>
                }
              >
                <Input
                  type="text"
                  label="Scan Name"
                  value={targetName}
                  onChange={handleNameChange}
                  required
                  error={isError.targetName}
                  helperText={isError.targetName}
                  disabled={
                    props.location.state != undefined &&
                    props.location.state.editData
                  }
                >
                  Scan Name
                </Input>
              </Tooltip>
            {/* </MuiThemeProvider> */}
          </span>
        </Grid>
        <Grid item xs={12} md={6}>
        <span className={styles.IPTooltip}>
          {/* <MuiThemeProvider theme={theme}> */}
            <Tooltip
              open={urlOpen}
              onClose={handleUrlToolTipClose}
              onOpen={handleUrlToolTipOpen}
              placement="bottom-end"
              title={
                <React.Fragment>
                   <p>
                    <b>Please enter data in the below formats </b>{" "}
                  </p>
                  <b>{"Single IP Address"}</b>
                  <em>{"(e.g. https://192.168.x.xx or http://192.168.x.xx)"}</em>{" "}
                  <p>
                  <b>For URL </b>{" "}
                  <em>{" (e.g :- https://domain.com or http://domain.com)"}</em>{" "}
                    {/* <b> Please enter Complete URL. e.g :- https://domain.com or http://domain.com</b>{" "} */}
                  </p>
                  {" "}
                </React.Fragment>
              }
            >
          <Input
            type="text"
            label="URL / IP"
            value={url}
            onChange={handleChangeUrl}
            required
            error={isError.url}
            helperText={isError.url}
          >
           URL/IP
          </Input>
          </Tooltip>
          </span>
        </Grid>
        <Grid item xs={12} md={6}>
          <AutoCompleteDropDown
            {...getAllPolicyValues}
            id="policyValue"
            value={policyValue ? policyValue : null}
            name="Policy Value"
            required
            onChange={handlePolicyValueChange}
            renderInput={(
              params:
                | (JSX.IntrinsicAttributes &
                    import("@material-ui/core").StandardTextFieldProps)
                | (JSX.IntrinsicAttributes &
                    import("@material-ui/core").FilledTextFieldProps)
                | (JSX.IntrinsicAttributes &
                    import("@material-ui/core").OutlinedTextFieldProps)
            ) => <Input {...params} id="policyValue" label="Scan Type *" />}
          />
        </Grid>
        <Grid item xs={12} className={styles.ActionButtons}>
          {/* <Button
            className={styles.borderLess}
            variant={"contained"}
            onClick={handleBack}
            color="primary"
            data-testid="cancel-button"
          >
            back
          </Button> */}

          <Button
            onClick={handleSubmitDialogBox}
            color="primary"
            variant={"contained"}
            data-testid="ok-button"
            type="submit"
            // disabled={submitDisabled}
          >
            Queue Scan
          </Button>
          <Button
            className={styles.borderLess}
            variant={"contained"}
            onClick={handleBack}
            color="primary"
            data-testid="cancel-button"
          >
            cancel
          </Button>
        </Grid>
      </Grid>
    </React.Fragment>
  );
};

export default PenTest;
